```C
The CTL `stk`, analogous to the STL `std::stack`, is a container
specializing in `O(1)` push (back) and pop (back) operations. A `stk` can be seen
as a simplified `deq`, and therefor maintains all pointer validity and memory
contiguousness properties of a `deq`.

```

typedef struct A
{
    void (*free)(T*);
    T (*copy)(T*);
    B** pages;
    size_t mark_a;
    size_t mark_b;
    size_t capacity;
    size_t size;
}
A;

static inline int
JOIN(A, empty)(A* self);

static inline A
JOIN(A, init)(void);

static inline T*
JOIN(A, top)(A* self);

static inline void
JOIN(A, pop)(A* self);

static inline void
JOIN(A, push)(A* self, T value);

static inline void
JOIN(A, clear)(A* self);

static inline void
JOIN(A, free)(A* self);

static inline A
JOIN(A, copy)(A* self);

static inline int
JOIN(A, equal)(A* self, A* other, int _equal(T*, T*));

# Example: Storing and Summing Integers

```C
#include <stdlib.h>
#include <stdio.h>

#define P
#define T int
#include <stk.h>

int main(void)
{
    stk_int a = stk_int_init();
    for(int i = 0; i < 16; i++)
        stk_int_push(&a, rand() % 1024);
    int sum = 0;
    while(!stk_int_empty(&a))
    {
        int* x = stk_int_top(&a);
        printf("%d\n", *x);
        sum += *x;
        stk_int_pop(&a);
    }
    printf("sum: %d\n", sum);
    stk_int_free(&a);
}
```

```shell
gcc test.c -I ctl
```

Memory ownership rules apply when `#define P` is omitted - simply declare
functions `T_free` and `T_copy`, as per usual, where `T` is the type `typedef`.
